# Copyright: Krzysztof Kowalczyk
# Owner: Szymon Knitter
#
# Purpose:
#  Movies yahoo  - parse(html)
#
import string
try:
    from BeautifulSoup import BeautifulSoup
    from BeautifulSoup import Tag
except Exception:
    print "requires BeautifulSoup module from http://www.crummy.com/software/BeautifulSoup/"
    raise

from entities import convertNamedEntities
from entities import convertNumberedEntities
from parserUtils import *
from ResultType import *

def getMovieAndTimes(next):
    movie = str(next.first("b").contents[0])
    temp = next.fetch("b")
    returnNone = True
    hours = ""
    if 1 < len(temp):
        if ("Showtimes:" == str(temp[1].contents[0])) or ("Buy Tickets:" == str(temp[1].contents[0])):
            returnNone = False
            nextH = temp[1].next.next.next
            endNow = False
            while nextH and (not endNow):
                if isinstance(nextH, Tag):
                    endNow = True
                    if (nextH.name == "a" or nextH.name == "span"):
                        endNow = False
                if not isinstance(nextH, Tag):
                    if 0 > str(nextH).find("Table"):
                        hours += str(nextH)
                nextH = nextH.next
            hours = str(hours).replace("\n"," ")
            hours = hours.lstrip()
    if returnNone:
        return None
    return (movie, hours)

# htmlTxt is a html page returned by yahoo!movies. Parse it and returned a tuple
# (typeOfResult,resultBody)
# typeOfResult can be:
#   MOVIES_DATA : resultBody is a list of movies and theaters. We get this if we
#      provided a valid location to yahoo
#   LIST_OF_LOCATION : resultBody is a list of locations. Happens if a location
#      given wasn't recognized by yahoo but it looks similar to other locations
#   LOCATION_UNKNOWN : yahoo didn't recognize the location and can't come up
#      with any suggestions. resultBody is None.
#   UNKNOWN_FORMAT : this doesn't even look like a page generated by yahoo
#      (or they've changed the format). resultBody is None
def parseMovies(htmlTxt):
    # what is this? do we need it?
    if len(htmlTxt) < 200 and len(htmlTxt) > 12:
        if htmlTxt[7:].startswith(".movies.dcn.yahoo.com uncompressed/chunked"):
            return (LOCATION_UNKNOWN,None)
        if htmlTxt[8:].startswith(".movies.dcn.yahoo.com uncompressed/chunked"):
            return (LOCATION_UNKNOWN,None)
        if htmlTxt[9:].startswith(".movies.dcn.yahoo.com uncompressed/chunked"):
            return (LOCATION_UNKNOWN,None)
    soup = BeautifulSoup()
    soup.feed(htmlTxt)

    testPage = soup.first("a", {"name":"T%"})
    innerList = []

    # result = ""
    if not testPage:
        # Location-Unknown
        # when <form method="get" action="/showtimes/showtimes">...<table>...<font color=red>
        testPage = soup.first("form", {"method":"get", "action":"/showtimes/showtimes"})
        if not testPage:
            testPage = soup.first("form", {"method":"get", "action":"http://movies.yahoo.com/showtimes/showtimes"})
        if testPage:
            next = testPage.next
            while next and not isinstance(next, Tag):
                next = next.next
            if next.first("font",{"color":"red"}):
                return (LOCATION_UNKNOWN,None)

        # Location-Abiguous
        # when <form method="get" action="/showtimes/showtimes" name="multiselect">
        testPage = soup.first("form", {"method":"get", "action":"/showtimes/showtimes", "name":"multiselect"})
        if testPage:
            result = ""
            locations = soup.fetch("input" ,{"type":"radio", "name":"z"})
            counter = 0
            for locationIn in locations:
                # innerList.append(str(locationIn.next).strip())
                result += str(locationIn.next).strip()
                if (counter < len(locations)-1):
                    result += "\n"
                counter += 1
            # if 0 == len(innerList):
            #    return (UNKNOWN_FORMAT, None)
            # return (LIST_OF_LOCATION, universalDataFormatReplaceEntities([innerList]))
            return (LIST_OF_LOCATION, result)

        bList = soup.fetch("b")
        for bItem in bList:
            text = getAllTextFromTag(bItem)
            if text == "Unknown problem":
                return (LOCATION_UNKNOWN,None)
            if text.startswith("User reviews is unavailable right now"):
                return (WEB_PAGE_UNDER_MAINTENANCE,None)
        return (UNKNOWN_FORMAT, None)

    outerList = []

    wasAnyTheater = False
    # ok that is right html
    # Get Theater: Address: Movie: Times: ...
    # firstTheater = 1
    for inTheater in soup.fetch("a", {"name" : "T%"}):
        wasTimes = False
        # get Theater
        firstList = [str(inTheater.first("b").contents[0]).replace("\n", " ").strip()]
        wasAnyTheater = True
        secondList = []
        next = inTheater.next
        getNext = 5
        wantMovie = False
        wantHours = False
        wasTimes = False
        while (getNext > 0 and next):
            if isinstance(next, Tag):
                if "a" == next.name:
                    if 1 == len(next.attrs):
                        temp, temp2 = next.attrs[0]
                        if ("name"== str(temp)) and str(temp2).startswith("T"):
                            if wasTimes:
                                if 2 != len(firstList):
                                    return (UNKNOWN_FORMAT, None)
#                                if 0 != (len(outerList) % 2):
#                                    return (UNKNOWN_FORMAT, None)
                                if 0 == len(secondList) or 0 != (len(secondList) % 2):
                                    return (UNKNOWN_FORMAT, None)
                                outerList.append((firstList, secondList))
                            getNext -= 5

                # searching address
                # in <td width=1% nowrap class=ygfa> (only to know - 3 atributes)
                if ("td" == next.name) and (5 == getNext):
                    if 3 == len(next.attrs):
                        text = next.contents[0]
                        text = str(text).replace("\n"," ")
                        text = text.strip()
                        wantMovie = True
                        firstList.append(text)
                        getNext -= 1

                # searching movie
                if ("td" == next.name) and wantMovie:
                    if 2 == len(next.attrs):
                        temp, temp2 = next.attrs[0]
                        if ("width" == str(temp)) and ("50%" == str(temp2)):
                            # we have movie!
                            tmpMovies = getMovieAndTimes(next)
                            if tmpMovies:
                                wasTimes = True
                                movie, hours = tmpMovies
                                secondList.append(movie)
                                secondList.append(hours)

            next = next.next
            if not next:
                if wasTimes:
                    if 2 != len(firstList):
                        return (UNKNOWN_FORMAT, None)
#                    if 0 != (len(outerList) % 2):
#                        return (UNKNOWN_FORMAT, None)
                    if 0 == len(secondList) or 0 != (len(secondList) % 2):
                        return (UNKNOWN_FORMAT, None)
                    outerList.append((firstList, secondList))
                getNext -= 5

    if 0 == len(outerList):
        if wasAnyTheater:
            return (NO_RESULTS, None)
        else:
            return (UNKNOWN_FORMAT, None)

    def row_compare(r1, r2):
        f1, f2 = r1[0], r2[0]
        th1, th2 = f1[0], f2[0]
        return cmp(th1, th2)

    outerList.sort(row_compare)
    flatList = []
    for row in outerList:
        flatList.append(row[0])
        flatList.append(row[1])

    return (MOVIES_DATA, universalDataFormatReplaceEntities(flatList))

def usage():
    print "usage: movies.py [-file $fileToParse]"

def main():
    fileName = arsutils.getRemoveCmdArg("-file")
    if 1 != len(sys.argv):
        usage()
        sys.exit(0)

    if None != fileName:
        fo = open(fileName, "rb")
        htmlTxt = fo.read()
        fo.close()
        (resultType, resultBody) = parseMovies(htmlTxt, fileName, fDebug=True)

    if MODULE_DOWN == resultType:
        print "module down"
    if PARSING_FAILED == resultType:
        print "parsing failed"
    if RESULTS_DATA == resultType:
        print "got BOXOFFICE"
        print udfPrettyPrint(resultBody)
        #print resultBody
if __name__ == "__main__":
    main()
